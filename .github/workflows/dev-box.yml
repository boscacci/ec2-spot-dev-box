name: dev-box

on:
  workflow_dispatch:
    inputs:
      action:
        description: "What to do"
        required: true
        default: "start"
        type: choice
        options:
          - start
          - destroy
          - plan
      flavor:
        description: "Instance size (leave blank to keep current)"
        required: false
        default: ""
        type: choice
        options:
          - ""
          - "Large: 4 vCPU, 32GB RAM (~$0.15/hr)"
          - "Medium: 4 vCPU, 16GB RAM (~$0.08/hr)"
          - "High: 8 vCPU, 64GB RAM (~$0.30/hr)"

permissions:
  id-token: write
  contents: read

jobs:
  terraform:
    runs-on: ubuntu-latest
    environment: dev-box
    env:
      TF_IN_AUTOMATION: "true"
      TF_INPUT: "false"
      # Backend config (prefer repo/env variables; allow env secrets as fallback)
      TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET || secrets.TF_STATE_BUCKET }}
      TF_STATE_KEY: ${{ vars.TF_STATE_KEY || secrets.TF_STATE_KEY }}
      TF_LOCK_TABLE: ${{ vars.TF_LOCK_TABLE || secrets.TF_LOCK_TABLE }}
      TF_STATE_REGION_RAW: ${{ vars.TF_STATE_REGION || secrets.TF_STATE_REGION }}
      TF_STATE_REGION: ${{ (vars.TF_STATE_REGION || secrets.TF_STATE_REGION) || 'us-west-2' }}
      AWS_REGION: ${{ (vars.TF_STATE_REGION || secrets.TF_STATE_REGION) || 'us-west-2' }}

      # Dev box inputs (optional; workflow input key_name is the fallback)
      DEVBOX_KEY_NAME: ${{ vars.DEVBOX_KEY_NAME || secrets.DEVBOX_KEY_NAME }}
      
      # Additional SSH public keys (newline-separated) to add to authorized_keys
      DEVBOX_ADDITIONAL_SSH_KEYS: ${{ secrets.DEVBOX_ADDITIONAL_SSH_KEYS || vars.DEVBOX_ADDITIONAL_SSH_KEYS }}

      # Auth (OIDC): allow storing as secret or variable at repo/env scope
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN || vars.AWS_ROLE_ARN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate backend variables
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${AWS_ROLE_ARN:-}" ]; then
            echo "Missing AWS_ROLE_ARN. Put it in the selected GitHub Environment (Secrets or Variables) or at repo-level." >&2
            echo "Expected value: bootstrap output 'gha_terraform_role_arn'." >&2
            echo "If your Environment requires approvals, approve the run so secrets are provided." >&2
            exit 2
          fi

          missing=0
          for v in TF_STATE_BUCKET TF_STATE_KEY TF_LOCK_TABLE; do
            if [ -z "${!v:-}" ]; then
              echo "Missing required Actions variable: $v" >&2
              missing=1
            fi
          done

          if [ "$missing" -eq 1 ]; then
            echo >&2
            echo "Set these at GitHub: Settings → Secrets and variables → Actions → Variables." >&2
            echo "You can get values from: terraform -chdir=bootstrap output" >&2
            exit 2
          fi

          if [ -z "${TF_STATE_REGION_RAW:-}" ]; then
            echo "NOTE: TF_STATE_REGION is not set; defaulting to '${TF_STATE_REGION}'." >&2
          fi

      - name: Generate terraform.tfvars (workflow-friendly)
        shell: bash
        run: |
          set -euo pipefail

          # EC2 key pair name (required repo variable)
          DEVBOX_KEY_NAME="${DEVBOX_KEY_NAME:-}"
          if [ -z "$DEVBOX_KEY_NAME" ]; then
            echo "Missing EC2 key pair name. Set repo variable DEVBOX_KEY_NAME." >&2
            exit 2
          fi

          # Defaults (override via GitHub Actions variables)
          DEVBOX_AWS_REGION="${DEVBOX_AWS_REGION:-${TF_STATE_REGION:-us-west-2}}"
          DEVBOX_AVAILABILITY_ZONE="${DEVBOX_AVAILABILITY_ZONE:-${DEVBOX_AWS_REGION}a}"
          DEVBOX_ALLOWED_SSH_CIDRS="${DEVBOX_ALLOWED_SSH_CIDRS:-[\"0.0.0.0/0\"]}"
          DEVBOX_CREATE_VPC="${DEVBOX_CREATE_VPC:-false}"
          DEVBOX_ENABLE_EIP="${DEVBOX_ENABLE_EIP:-true}"
          DEVBOX_INSTANCE_NAME="${DEVBOX_INSTANCE_NAME:-dev-box}"

          DEVBOX_EBS_SIZE_GB="${DEVBOX_EBS_SIZE_GB:-96}"
          DEVBOX_EBS_VOLUME_TYPE="${DEVBOX_EBS_VOLUME_TYPE:-gp3}"

          DEVBOX_ENABLE_CLAUDE_SECRET="${DEVBOX_ENABLE_CLAUDE_SECRET:-true}"
          DEVBOX_CLAUDE_SECRET_ID="${DEVBOX_CLAUDE_SECRET_ID:-CLAUDE_API_KEY}"
          DEVBOX_CLAUDE_SECRET_REGION="${DEVBOX_CLAUDE_SECRET_REGION:-$DEVBOX_AWS_REGION}"

          # Build additional SSH keys JSON array
          ADDITIONAL_SSH_KEYS_JSON="[]"
          if [ -n "$DEVBOX_ADDITIONAL_SSH_KEYS" ]; then
            # Convert newline-separated keys to JSON array
            ADDITIONAL_SSH_KEYS_JSON="$(echo "$DEVBOX_ADDITIONAL_SSH_KEYS" | jq -R -s 'split("\n") | map(select(length > 0))')"
          fi

          cat > terraform.tfvars <<EOF
          aws_region        = "$DEVBOX_AWS_REGION"
          availability_zone = "$DEVBOX_AVAILABILITY_ZONE"

          # NOTE: GitHub Actions cannot read your local public key file.
          # Use an existing EC2 key pair and keep ssh_public_key_path empty.
          key_name            = "$DEVBOX_KEY_NAME"
          ssh_public_key_path = ""
          
          # Additional SSH public keys synced from GitHub Secrets
          additional_ssh_public_keys = $ADDITIONAL_SSH_KEYS_JSON

          allowed_ssh_cidrs = $DEVBOX_ALLOWED_SSH_CIDRS

          create_vpc = $DEVBOX_CREATE_VPC
          enable_eip = $DEVBOX_ENABLE_EIP
          instance_name = "$DEVBOX_INSTANCE_NAME"

          ebs_size_gb     = $DEVBOX_EBS_SIZE_GB
          ebs_volume_type = "$DEVBOX_EBS_VOLUME_TYPE"

          enable_claude_api_key_from_secrets_manager = $DEVBOX_ENABLE_CLAUDE_SECRET
          claude_api_key_secret_id = "$DEVBOX_CLAUDE_SECRET_ID"
          claude_secret_region     = "$DEVBOX_CLAUDE_SECRET_REGION"
          EOF

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.TF_STATE_REGION }}

      - name: Show spot vs on-demand pricing
        run: ./scripts/prices.sh || true

      - name: Terraform init (S3 backend)
        run: ./scripts/tf_init.sh

      - name: Safety check - preserve infrastructure settings from state
        shell: bash
        run: |
          set -euo pipefail
          
          # Check if VPC exists in current state
          VPC_IN_STATE=$(terraform show -json 2>/dev/null | jq -r '.values.root_module.resources[]? | select(.address == "aws_vpc.dev_box[0]") | .values.id' || echo "")
          
          if [ -n "$VPC_IN_STATE" ]; then
            echo "VPC found in state ($VPC_IN_STATE). Ensuring create_vpc = true to prevent accidental destruction."
            sed -i 's/^create_vpc = false/create_vpc = true/' terraform.tfvars
          fi
          
          # Check if a Terraform-managed key pair exists in state
          KEY_PAIR_IN_STATE=$(terraform show -json 2>/dev/null | jq -r '.values.root_module.resources[]? | select(.address == "aws_key_pair.dev_box[0]") | .values.key_name' || echo "")
          
          if [ -n "$KEY_PAIR_IN_STATE" ]; then
            echo "ERROR: Managed EC2 key pair found in state ($KEY_PAIR_IN_STATE), but GitHub Actions cannot manage key pairs (no access to local public key file)."
            echo ""
            echo "To fix this, you must:"
            echo "1. Manually import an existing EC2 key pair in AWS Console (or create one)"
            echo "2. Locally run: terraform state rm 'aws_key_pair.dev_box[0]'"
            echo "3. Update your local terraform.tfvars: set ssh_public_key_path = \"\""
            echo "4. Set GitHub variable DEVBOX_KEY_NAME to the existing key pair name"
            echo "5. Re-run this workflow"
            echo ""
            echo "Alternatively, manage start/stop from your local machine where you have the key files."
            exit 1
          fi

      - name: Map flavor to Terraform values
        id: map_flavor
        shell: bash
        run: |
          FLAVOR_INPUT="${{ inputs.flavor }}"
          case "$FLAVOR_INPUT" in
            "Large"*) echo "tf_flavor=large" >> "$GITHUB_OUTPUT" ;;
            "Medium"*) echo "tf_flavor=medium" >> "$GITHUB_OUTPUT" ;;
            "High"*) echo "tf_flavor=xl" >> "$GITHUB_OUTPUT" ;;
            "") echo "tf_flavor=" >> "$GITHUB_OUTPUT" ;;
            *) echo "ERROR: Invalid flavor: $FLAVOR_INPUT" >&2; exit 1 ;;
          esac

      - name: Terraform plan
        if: ${{ inputs.action == 'plan' }}
        run: |
          if [ -n "${{ steps.map_flavor.outputs.tf_flavor }}" ]; then
            terraform plan -var="flavor=${{ steps.map_flavor.outputs.tf_flavor }}"
          else
            terraform plan
          fi

      - name: Terraform apply (start)
        if: ${{ inputs.action == 'start' }}
        run: |
          if [ -n "${{ steps.map_flavor.outputs.tf_flavor }}" ]; then
            terraform apply -auto-approve -var="enable_instance=true" -var="flavor=${{ steps.map_flavor.outputs.tf_flavor }}"
          else
            terraform apply -auto-approve -var="enable_instance=true"
          fi
          echo "ssh_host=$(terraform output -raw ssh_host || true)" >> "$GITHUB_OUTPUT"
          echo "ssh_command=$(terraform output -raw ssh_command || true)" >> "$GITHUB_OUTPUT"

      - name: Terraform apply (destroy)
        if: ${{ inputs.action == 'destroy' }}
        run: terraform apply -auto-approve -var="enable_instance=false"

